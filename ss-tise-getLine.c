#include "ss-tise-shell.h"
/**
 * input_buf - Reads a line from the standard input and stores it
 * in a buffer.
 * @info: A pointer to a var_info_t structure.
 * @buf: A pointer to the buffer where the input line
 * will be stored.
 * @len: The length of the buffer.
 *
 * Return: The number of characters read, or -1
 * if an error occurred.
 */

ssize_t input_buf(var_info_t *info, char **buf, size_t *len)
{
	ssize_t v = 0;
	size_t var_len_p = 0;
	int newline_flag = 0;
	char newline_char = '\n';
	char null_char = '\0';

	if (!*len)
	{
		free(*buf);
		*buf = NULL;
		signal(SIGINT, sigintHandler);
#if USE_GETLINE
		v = getline(buf, &var_len_p, stdin);
#else
		v = _getline(info, buf, &var_len_p);
#endif
		if (v > 0)
		{
			newline_flag = ((*buf)[v - 1] == newline_char) ? 1 : 0;
			(*buf)[v - 1] = newline_flag ? null_char : (*buf)[v - 1];
			if ((*buf)[v - 1] == null_char)
			{
				--v;
			}
			info->linecount_flag = 1;
			remove_comments(*buf);
			build_history_list(info, *buf, info->histcount++);
			*len = v;
			info->cmd_buf = buf;
		}
	}
	return (v);
}

/**
 * get_input - Gets a line without the newline.
 * @varInfo: The parameter struct.
 * Return: Returns bytes read.
 */
ssize_t get_input(var_info_t *varInfo)
{
	static char *buffer;
	static size_t head, offset, bufferLength;
	ssize_t result = 0;
	char **bufferPointer = &(varInfo->arg), *temp;

	_putchar(BUF_FLUSH);
	result = input_buf(varInfo, &buffer, &bufferLength);
	if (result == -1) /* EOF */
		return (-1);
	if (bufferLength)
	{
		offset = head;
		temp = buffer + head;

		check_chain(varInfo, buffer, &offset, head, bufferLength);
		while (offset < bufferLength)
		{
			if (is_chain(varInfo, buffer, &offset))
				break;
			offset++;
		}

		head = offset + 1;
		if (head >= bufferLength)
		{
			head = bufferLength = 0;
			varInfo->cmd_buf_type = CMD_NORM;
		}

		*bufferPointer = temp;
		return (_strlen(temp));
	}

	*bufferPointer = buffer;
	return (result);
}
/**
 * read_buf - Reads from a file descriptor into a buffer..
 * @info: a pointer to a var_info_t structure.
 * @buf: a character buffer.
 * @i: a pointer to a size_t variable.
 *
 * Return:The number of bytes read, or -1 if there was an error.
 */
ssize_t read_buf(var_info_t *info, char *buf, size_t *i)
{
	ssize_t szr = 0;
	int z = 0;
	size_t bufferSize = READ_BUF_SIZE;

	if (*i)
		return (z);
	while ((szr = read(info->readfd, buf, bufferSize)) > 0)
	{
		*i += szr;
	}
	return (*i);
}

/**
 * _getline - Reads a line from a file descriptor into a buffer.
 *
 * @info: A pointer to a var_info_t structure that contains
 *         the file descriptor to read from.
 * @ptr: A pointer to the buffer where the read line will be stored.
 * @length: A pointer to a size_t variable where the
 *          length of the read line will be stored.
 *
 * This function reads characters from a file descriptor into a static buffer
 * until it encounters a newline character ('\n'). If it reaches the end of
 * the buffer without finding a newline, it increases the size of the buffer
 * and continues reading. If memory allocation fails during this process,
 * it frees any previously allocated memory and returns -1.
 *
 * Return: The length of the read line, or -1 if an error occurred or if
 *         there is no more data to read.
 */
int _getline(var_info_t *info, char **ptr, size_t *length)
{
	static char buf[READ_BUF_SIZE];
	static size_t g, varlen;
	size_t q;
	ssize_t d = 0, varsz = 0;
	char *x = NULL, *new_p = NULL, *f;
	size_t bufferSize = READ_BUF_SIZE;

	x = *ptr;
	if (x && length)
		varsz = *length;
	if (g == varlen)
		g = varlen = 0;

	d = read_buf(info, buf, &varlen);
	if (d == -1 || (d == 0 && varlen == 0))
		return (-1);

	f = _strchr(buf + g, '\n');
	q = f ? 1 + (unsigned int)(f - buf) : varlen;
	new_p = _realloc(x, varsz, varsz ? varsz + q : q + bufferSize);
	if (!new_p) /* MALLOC FAILURE! */
		return (x ? free(x), -1 : -1);

	if (varsz)
		_strncat(new_p, buf + g, q - g);
	else
		_strncpy(new_p, buf + g, q - g + 1);

	varsz += q - g;
	g = q;
	x = new_p;

	if (length)
		*length = varsz;
	*ptr = x;
	return (varsz);
}
/**
 * sigintHandler -This function handles the SIGINT signal
 * (generated by Ctrl+C). When the signal is received,
 * it prints a newline and a prompt to the standard output,
 * and flushes the output buffer.
 * @intsig_num: The number of the signal that caused invocation of
 *the handler. This parameter is unused.
 *
 */
void sigintHandler(__attribute__((unused))int intsig_num)
{
	char *prompt = "$ ";
	char newline_str[] = "\n";
	int buffer_flush = BUF_FLUSH;

	_puts(newline_str);
	_puts(prompt);
	_putchar(buffer_flush);
}

